### http 状态码
1. 1xx 已经发送请求，服务器接收到了 等待进一步处理。
2. 2xx 请求成功，服务器也处理好了。
206：客户端发送一个带range头的get 请求，服务器完成了它。range 头是指规定范围，服务器返回范围内的数据回来
3. 3xx 重定向。常见code 
301：永久被重定向了
302：暂时重定向 
304：客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档），服务器发现缓存有用则返回304 告诉客户端用缓存。

4. 4xx 请求错误
400 请求发生语法错误
403 资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。
404 找不到资源
414 uri 太长
5. 5xx 服务器发生错误
500：服务器遇到了意料不到的情况，不能完成客户的请求
502：
503：
505：不支持指明的http 版本

### HTTP 缓存有哪几种？
#### 强制缓存

强制缓存服务器通知浏览器一个缓存时间，如果还在时间内，则使用本地缓存,不会请求服务器，一般在响应头里面cache-control或者expires来设置

http1.1 版本
cache-control： public | max-age（s-maxage） | must-revalidate 
[public] 的值可以为： 
public:可以缓存，既可以本地缓存，也可以cdn 缓存
private：可以缓存，只能本地缓存
no-cache：告诉客户端不能直接使用缓存，需要服务器二次校验才能决定是否可用（服务器返回304才可用）
no-store：不能缓存
[max-age]： 缓存时间，是一个相对时间，单位为s。例如 max-age = 3000 秒 s-maxage=1000  共享缓存有效期1000秒
[must-revalidate]

http1.0 版本
Pragma 跟cache-control类似。现在基本不用了
expires：设置缓存时间，是绝对时间。返回的是到期时间 是http1.0 版本的东西，现在主要为http1.1版本用cache-control 控制，如果两个都设置了，以cache-control 的时间为准。
强缓存优先级：pragma > cache-control > expires

强缓存返回的状态码：
200（from disk cache） 从磁盘中读取，一般为css js 脚本
200（from memory cache） 从内存中读取，一般为图片字体
首先是访问内存是否有缓存，再访问磁盘 没有则请求服务器。

#### 对比缓存
对比缓存是指无论什么情况都会请求服务器，来对比本地缓存是否跟服务器缓存一致，如果一致则返回304 告诉客户端缓存可直接使用，不会发送新的资源。否则发送最新资源。
有2种标识传递
1. Last-Modified（响应头里包含） / If-Modified-since（请求头里包含） :以修改时间为值
Last-Modified 第一次请求服务器返回值，代表最后一次修改时间。
在第二次请求的时候header 带If-Modified-since 字段该字段为Last-Modified 的最后一次修改时间，服务器接收到对比最新资源的时间是否大于该字段，如果是则说明修改过，返回200状态码及最新资源给客户端，客户端保存最新资源在本地。否则只返回header 状态码为304 通知浏览器用缓存资源。

2. Etag / If-None-Match ：以资源的唯一标识为值
Etag 第一次请求服务器的返回资源的唯一标识值
If-None-Match 第二次请求的时候客户端在请求头带上该字段（值为Etag的值），服务器判断该标识是否是最新资源，如果没有被修改过 则返回304 ，被修改过就返回200 及最新的资源和Etag 给客户端。

对比缓存的优先级（Etag > Last-Modified）

#### http缓存优先级
如果同时存在强缓存和对比缓存，如果强缓存还在有效期中则直接命中缓存，不走对比缓存。如果强缓存不在有效期中则判断对比缓存。
强缓存 > 对比缓存

### Cookie V.S. LocalStorage V.S. SessionStorage V.S. Session
session、cookie 都是用来保持状态信息的会话方式。
cookie 保存在前端浏览器，session 保存在服务端。
cookie缺点：
1. 大小有限4k
2. 可以被禁止，功能受限
3. 只能存文本字符串格式，对象需要转换成字符串保存
4. 可以被盗取
5. 每次请求都要带给服务端浪费带宽
6. 有path 的概念，被限制在某个路径下面
#### cookie 的创建
通常是后端创建好
cookie 是服务器发送给客户端的特殊信息，cookie是以文本方式保存在客户端，前端每次请求都带上cookie 给服务器。
cookie 分为会话性cookie 和 持久性cookie，会话cookie 在关闭浏览器就消失，存在内存里面。持久性cookie 存在磁盘里面（存活期）
session 服务器为每个客户端开内存，保持状态信息，需要一个sessionid一样的东西，该id 一般是通过cookie 保存。session 就是一种map 数据，在创建的时候会自动生成sessionid 自动在header 加在cookie里面。

#### localstorage sessionstorage
两个内存都是同域共享，比cookie内存大 接近5m
localStorage 是一种本地缓存，存在磁盘中，没有时效性，只要用户不手动清除会一直存在本地，长久性的持久性。
sessionStorag 是一种会话级的缓存，当同域页面关闭就会消失。只具有暂时性的持久性

### GET 和 POST 区别
从本质上来说两者没有区别，都是tcp/ip 协议。从语义上来说有区别，参考以下第一点
1. get字面含义就是从服务器上获取信息，post 主要是把数据传送给服务器
2. 在数据传送的方式有区别，get 是把参数放在url后面，post 把数据放在body里面
3. 浏览器对get的url 的长度有限制，


### http协议主要特点
1. 简单快速：uri 是固定的，统一资源符
2. 灵活：可以完成多种数据传输
3. 无连接：每次完成数据传输之后就会断开
4. 无状态：客户端和服务端不会记住两次状态和身份
### http报文的组成部分
请求报文：请求行（请求方法 地址 http版本 ） + 请求头（key-value）+ 空行 + 请求体
响应报文：响应行（ http版本 状态码和描述） + 响应头（key-value） + 空行 + 响应体
### http方法
post get put delete 
### 什么是持久连接
http 采用请求-应答模式，普通模式（非keep-alive模式），每个请求都需要新建一个连接，完成后就立即断开连接
持久连接：keep-alive 创建连接后不断开，以后每次连接不需要再重新建立连接，http1.1 开始支持。节省了创建连接的时间。
### 什么是管线化
管线化和持久连接的区别就是管线化把请求全部发送完成后响应再全部发送回来，而持久连接是发送一次请求就返回一个响应。管线化需要手动设置，只有GET HEAD 等操作可以管线化，POST不支持管线化。
持久连接：请求 -> 响应 -> 请求 -> 响应
管线化：请求 -> 请求 -> 响应 -> 响应