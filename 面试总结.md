## 记成都第二次面试
### VUE 的数组有些改变方法不更新视图的原因是什么？
vue 双向数据绑定的原理是利用Object.defineProperty() 做数据挟持的，object.defineProperty()的主要问题有，1.不能检测数组的变化，2.必须深层遍历嵌套的对象。
1. 不能检测数组的变化
数组的一些方法是不会触发set的，比如push, pop, shift, unshift,splice, sort, reverse（修改原有数组的方法定义为变异方法，vue框架对这些方法进行了hack）。
非变异方法 例如 concat filter slice 会返回一个新的数组，会触发视图更新

2. 只能挟持对象的属性，对于属性也是对象的必须要深度遍历

vue 3.x 版本使用proxy 替换object.defineProperty()
Proxy 的优点：
可以直接监听对象而非属性
可以直接监听数组的变化
有13种拦截方法
proxy 返回一个新对象，我们可以只操作新的对象达到目的，defineProperty 只能遍历对象属性直接修改
缺点：兼容性差，没有polyfill可以处理。
proxy 可以在外界访问对象之前进行拦截，通过这层拦截可以做到对外界的访问和改写做过滤。
### vue watch 和 computed 的区别？ watch 能检测到嵌套对象的吗？
watch 是观察的动作，没有缓存性，页面重新渲染时值不变化也会执行 <br>
computed 时计算值，具有缓存性，页面重新渲染值不变化,计算属性会立即返回之前的计算结果，而不必再次执行函数
### v-if VS v-show
v-if 是动态的向dom 树内添加或者删除dom 元素；v-show 是通过设置dom 元素的dispaly样式控制。
v-if 有更高的切换消耗，v-show 有更高的初始渲染消耗。
v-if 适合不怎么可能改变的，v-show 适合频繁切换的条件使用。
### vuex 的缺陷
我的回答是 看项目是否需要vuex 没用好反而会有性能问题。
### vue-router 的 跳转方式跟location 跳转的区别
vue-router 时前端路由跳转方式，不会涉及服务器，是前端利用hash 或者 pushState 实现的
传统的location 跳转方式会请求服务器，服务器做对应的操作。
### vue-router hash 和 history 的区别？
1. hash 模式带有#，history 中没有
2. 回车刷新hash 是可以加载对应的页面，history 页面如果没处理会报错404
3. hash 支持低版本浏览器和ie 浏览器，history 是需要html5 的新api
解析：
hash 模式主要是利用window 可以检测onhashchange 事件，# 后面的值变化可以做一些异步加载。
history模式 是利用HTML5 新特性 pushState 和 replaceState 实现的，可以将url 替换并且不会刷新页面，http 不会去请求服务器，但是刷新之后就会请求对于的url，显示404。需要后端做简单的处理找不到资源时重定向到入口文件。
### for in 和 for of 的区别
for...in 循环 用于遍历数组或者对象的属性。以任意顺序遍历一个对象的可枚举属性（从构造函数中继承属性也包括。）ps：对于数组使用，数组索引值就是其属性
for...of 循环是es6的新语法，用for...of循环遍历集合。遍历对象会报错。

### vue 组件之间的通信方式
1. props 和 $emit 
父组件通过props 传递数据给子组件，子组件传递数据是通过$emit 触发事件来做到。
2. $attrs 和 $listeners 
隔代组件通过props 传递很复杂，通过$attrs 和 $listeners 可以解决。
3. 中央事件总线
兄弟组件之间的数据传递，新建一个Vue事件bus 对象，通过bus.$emit 触发事件，bus.$on 监听触发的事件
4. provide 和 inject
父组件中通过provider 提供变量，然后再子组件通过inject 来注入变量。不管子组件有多深都可以用inject 获取provider的数据。
5. v-model
父组件通过v-model 传递值给子组件时，会自动传递一个value的props 属性，在子组件中通过this.$emit('input',val)自动修改v-model绑定的值。
6. $parent 和 $children
父元素通过this.$children 直接获取到子组件的data 修改，子组件通过this.$parent 直接获取父组件的data
7. vuex
### vue 插槽
单个插槽：默认插槽，当子组件模板只有一个没有属性的插槽时候，父组件传入的内容片段会插入其中。
具名插槽：通过<slot name="xx"> 指定有name的插槽，在父组件使用内容片段的时候 <h1 slot="xxx"> 会把对应的内容插到对应name的slot 上去。如果父组件没有指定哪个插槽则插入默认匿名插槽，如果不存在匿名插槽，则这个片段丢失。
作用域插槽：用作一个（能被传递数据的）可重用模板来代替已经渲染好的元素,子组件通过传入一个属性，父组件需要使用slot-scope=“props” 可以通过props 来获取到子组件传递的属性
子组件
```
<div class="child">
    <slot text="hello from child"></slot>
</div>
```
父组件
```
<div class="parent">
    <Child>
        <div slot-scope="props">
            <span>{{props.text}}</span>
        </div>
    </Child>
</div>
```
渲染结果
```
<div class="parent">
    <div class="child">
        <span>hello from child</span>
    </div>
</div>
```

## 成都第三次笔试+面试
### 笔试部分：
### window.onload 和 $(document).ready() 的区别
$(document).ready()：是在dom结构绘制完毕就执行，不用等待页面其他资源加载完毕，是可以写多个函数并且都会执行的。<br>
window.onload:是页面所有的元素都加载完毕，包括图片等元素，只能执行一次。
$(document).ready的执行时间是优先与window.onload 。
### 手写ajax
```
function ajax(){
    if(window.XMLHttpRequest){
        var xhr = new XMLHttpRequest()
    }else{
        var xhr = ActiveXObject()
    }
    xhr.open('get',url)
    xhr.send(data)
    xhr.onreadystatechange = function(){
        if(xhr.readyState == 4 && xhr.status == 200){
            return xhr.responseText

        }
    }
}
```
### dom 对象和 jq对象的转换
dom对象转换成jq对象直接使用$(dom) 即可，jq 对象转换成dom 对象使用jq对象的get()方法，或者使用通过对jq对象使用下标索引值获取。
### 变量提升
```
var a = 1
function f(){
    console.log(a) 
    var a = 2 // var a 被提升到函数开头，
    console.log(a)
}
f() // undefined, 2
```
### 类型转换
```
console.log(1 == '1') //true
console.log(1 === '1') //false
console.log(true == 'true') //false
console.log(true === 'true') //false
var a = {name:'1'}
var b = {name:'b'}
console.log(a == b) //false
```
### 显示隐藏的方式
display:none;
visibility:hidden
opacity:0
z-index:-9999
transform(0,0)
### 闭包

### 面试部分：
优化方案，调试方式 vue中常遇到的问题。
### 错误类型
1. SyntaxError:语法错误
2. Uncaught ReferenceError：引用错误：引用了一个不存在的变量发生的错误，将一个值分配给无法分配的对象。
3. RangeError：范围错误：当只有一个超出有效范围时发生的错误。比如，数组长度为负数，Number对象的方法超出范围，函数堆栈超过最大值。
4. TypeError类型错误：变量或参数不是预期类型时发生的错误。
5. URIError，URL错误
6. EvalError eval()函数执行错误， es5 以下的js 中eval 函数发生的错误，es5 已经不抛出这种错误了。
### postMessage 跨域
### 设计模式了解哪些
单例模式，观察者模式，工厂模式，命令模式，职责链模式
### vue 的优点
vue 的特性：轻量级的框架，具有双向数据绑定，强大的指令，插件化。
vue 的优点：简单易用，灵活渐进式（渐进式的理解，当只有小需求的适合vue即可，如果需要ajax 请求引入ajax库即可，如果需要router再引入vue-router。可以通过插件往上拓展自己的功能），轻量高效（压缩后源码小，虚拟dom），mvvm（数据驱动视图），组件化
缺点：vue 不支持ie8，仅限于view层，ajax 等功能需要额外插件。
### websocket
websocket 是html5 新增的协议，为了在浏览器和服务器之间建立一个不受限的双向通信的通道。
为什么http 协议不能做到websocket 的功能，因为http 协议是请求-响应协议，请求必须由浏览器发起，服务器响应请求。
轮询和comet 也能实现，轮询是浏览器开定时器请求，这样对服务器压力极大且实时性不够。

### VueRouter 你怎么用的？
使用vue 做项目的一个页面是多个组件组成的，在页面之间的跳转使用vue-router来跳转，vue-router 的简单使用主要是 先注册路由，将路由注册到VM组件中，定义组件，在组件中使用跳转。可以通过query 或者 params 来传递参数给组件。$route  是当前router跳转对象里面可以获取到相关信息，$router 是vuerouter实例，里面有跳转方法。

### 路由守卫
导航守卫是用取消或者通过的方式来守卫导航，分为全局的和组件级的。
全局守卫：
router.beforeEach(to,from,next) 全局前置守卫，导航触发的时候调用
router.afterEach(to,from) 全局后置钩子
to:即将要进入的目标路由对象
from 当前导航要离开的路由对象
next() 需要调用该方法才会进入或者离开路由。
局部守卫：
在组件内的钩子函数：
beforeRouteEnter(to,from,next)  在渲染组件的对应路由被comfirm前调用，不能访问this，因为新的组件还没有被创建，可以传回调通过next来访问vm 组件实例。组件内的钩子函数中唯一一个需要在next 中回调函数，beforeRouteUpdate 和 beforeRouteLeave 已经可以访问this了。
beforeRouteUpdate(to,from,next) 在当前路由改变，但是组件被复用的时候调用
beforeRouteLeave(to,from,next) 导航离开当前组件的时候调用，离开守卫可以用来取消用户的离开。
 
